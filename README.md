# Curso Profesional de Git y GitHub
# Para inicializar proyecto en git (github)
## Inicializa git en proyecto actual. Se crea un area de memoria ram y un directorio .git y lo estoy agregando al staging area y con git add lo agrego y el archivo pasa a vivir en staging y el archivo esta esperando que lo agregue al repositorio.
# El objetivo es bajar solamente textos planos (ni Word, ni .rtf, ni imagenes que son archivos binarios y que serian pesados para una adecuada respuesta por parte de Git). Los archivos binarios no permiten guardar solo los cambios sino que involucran volver a grabar el archivo completo en cada modificacion.
# Un VCS (Version Control System) registra los cambios realizados sobre un archivo o conjunto de ellos de modo que puedas llevar el historial comparando cambios en el tiempo, ver quien los realizo o revertir el proyecto entero a un estado anterior. Cualquier archivo ubicado en un ordenador puede someterse a un VCS (Version Control System). GitHub es una plataforma de desarrollo colaborativo  donde se crea codigo fuente de programas de computadora. GitHub es la red social de codigo para programadores en la cual se guardan los portafolios de proyectos de programacion. GitHub permite colaborar para mejorar los proyectos de otros y a otros mejorar o aportar a los tuyos. GitHub permite tener un mejor mantenimiento de distintos entornos y detectar fallos rapida y eficientemente.
# En nuestra maquina local utilizamos Git. Funciona en la terminal y lineas de comando. Utilizas GitHub si quieres usar una interfaz con otros, usar una interfaz web o publicar tus proyectos en la web. GitHub guarda cada uno de tus proyectos, sus cambios y cada una de sus versiones. GitHub termina siendo una hoja de vida que demuestra lo que sabes. Git no es solo add, tag, push, pull, branch, reflog, flow, merge, rebase, checkout, commit sino tambien Branch, Blame, remote y colaboradores. Instalas git desde su pagina https://git-scm-com/download
# Linux y MacOS basado en Unix son entornos mas amigables para programadores que Windows. Pero Git instala Git Bash en Windows, y tambien se puede usar git desde la linea de comandos nativos de Windows Cmd (terminal DOS). Puedes utilizar Git desde la terminal emulada de Linux que instala el sistema en Windows, o si lo quieres usar desde cualquier parte a traves de la instalacion Git from the command line and also from 3rd-party software. No hay nada que perder con esta ultima version de instalacion. Esta te permite utilizarlo desde la linea de comandos que ya es nativa de Windows. En Linuz y MacOS ya esta instalada una libreria Open SSL (ssh, ssl, llaves publicas y privadas) que es un sistema que permite intercambiar llaves de criptografia. Al no estar por defecto instalada en Windows puede utilizarse https (cambia llaves de criptografia). En Windows hay Windows Certificate Store, por lo que podemos seleccionar y utilizar en Windows la opcion OpenSSL Library. La primera opcion para configurar "Checkout Windows-style, commit Unix-style line endings" te permite tener mayor compatibilidad con todas las versiones. A continuacion lo mejor es seleccionar la opcion "Use MinTTY (the default terminal of MSYS2)" pues de todos modos vas a estar utilizando comandos de Linux como programador. A continuacion podemos bajar la versioon Ubuntu de Linux (la mas ampliamente utilizada por simplicidad y prestaciones). Finalmente tengo un terminal con lineas de comando que se parecen a las de Linux dentro de Windows. Ahora en Windows Para abrir este terminal presionas la tecla Win (Windows) y escribes Git bash le das enter y te la abre.
# Para instalar software en Linux derivado de Debian es mediante apt-get install git. Se recomienda instalar un update y upgrade para actualizar la instalacion mediante sudo apt-get update (super user do comando para tener poder de administrador; a continuacion escribiremos el password). sudo apt-get upgrade git (a continuacion colocaremos el password). Como editor de texto utilizaremos Visual Studio Code dandole click para la instalacion "Open with Code" lo que permite abrirlo con Visual Studio Code. En el mundo de Git lo que vamos a poder editar y guardar como version son archivos de texto (no binarios) para aprovechar el comportamiento atomico (cada modificacion se guarda independientemente) en GitHub.
# A continuacion le indicamos a Git que queremos crear un nuevo repositorio para utilizar su VSC (Version Control System). Tras ejecutar este comando de ahora en adelante tendremos una carpeta oculta llamada .git con toda la base de datos con cambios atomicos (cada cambio se guarda de manera independiente) en nuestro proyecto.
git init
# A continuacion le indicamos nuestro email
git config --global user.email "Miemail"
# A continuacion le indicamos nuestro nombre
git config --global user.name "Tu nombre"
# Si te equivocaste en el email o nombre lo puedes modificar mediante
git config --global --replace-all user.email "Y aqui va tu email corregido"
git config --global --replace-all user.name "Y aqui va tu nombre corregido"
# Si lo deseas eliminar y anadir uno nuevo
git config --global --unset-all user.email :Elimina el email del usuario
git config --global --add user.email "Aqui va tu email corregido"
git config --global --unset-all user.name :Elimina el nombre del usuario
git config --global --add user.name "Aqui va tu nombre corregido"
# Se puede agregar un archivo mediante git add biografia.txt, pero para que todos los cambios realizados en los archivos incluidos en el directorio en el que me encuentro se haran de una vez si utilizo mas bien git add . (este comando con el punto agregara todos los archivos que han cambiado)
# Para saber en que status se encuentra ahora
git status
## Agrega archivos a Staged
git add -A
git add .
# Tras haber guardado en el Staging (Ram) para borrarlo de Stage seria mediante
# git rm --cached historia.txt
# Para ver las posibles configuraciones
git conf
# Para ver la lista de configuraciones hechas
git conf -list
# Para mostrar las configuraciones y sus rutas
git config --list --show-origin
# Para eliminar el archivo del Staged (Ram)
git rm --cached nombre_del_archivo.txt
# Para eliminar archivo del repositorio
git rm nombre_del_archivo.txt
## Haces commit de cambio de version con nombre de commit. Asi lo pongo en el repositorio. El nombre del repositorio es Master y ahi estaran todos los cambios que yo haga. Una vez dado el git add . entra el archivo a ser tracked y esa modificacion se va a Staging. Solo llega al Staging tras darle el git add . Con el commit pasan de trackeados en el Staging a trackeados en el repositorio. Voy a una branch para traerme a mi carpeta los cambios de una version previa hacia mi carpeta. Cada vez que hago un commit estoy creando una nueva version de cambios hacia el repositorio y se identifican individualmente con esos numeros largos.
# Git  esta optimizado para guardar canbios de forna incremental. Permite tener un historial, regresar a una version anterior y agregar funcionalidades. Lleva un registro de los cambios que otras personas realicen en los archivos. Git fue disenado para operar en un entorno Linux, compatible tanto con Linux, MacOS y Windows. Los tres posibles estados en los que se encuentra un archivo son: Staged, Modified y Commited.
# Para enviarlo al repositorio junto con el mensaje que debo colocar descriptivo del cambio realizado
# No puedo hacer un commit sin haber realizado primero un git add . pues no lo hara. Primero debe estar en Stage (Ram) mediante git add y luego puede ir al repositorio mediante git commit
# Master es nuestra branch main (rama principal) en ella tenemos todas las historias de nuestros commits. El commit mas reciente es el que llamamos head.
# El checkout al head del master es realizado a la branch main
git commit -m "First commit name"
# Si no he incluido el mensaje, commit me lo pedira (le dare entonces Ã‹sc"+ i para escribir el mensaje y lo incluire entonces. Para salir de ahi le doy a "Esc"+ Shift + zz (esto fuerza el envio del commit porque guarda el archivo) "Esc"+ Shift + zz es la forma de guardar en vim.
# Dandole a git log o mejor aun a git log --stat puedo ver en detalle los cambios realizados.
# Para crear la branch la misma se creara desde el directorio donde estoy. Mi head que es mi apuntador del lugar de trabajo donde estoy me apunta a Main (Master)
# Si le doy a git status me mostrara en que branch estoy (On branch master)
# Con git show se donde esta el Head (el lugar donde estoy trabajando ahora mismo) y me muestra el ultimo cambio que hice, y desde aqui veo donde me indica que estoy el Head -> main. A continuacion le doy a q para salir de aca (git show)
# Si a continuacion le doy git branch cabecera pareciera no haber pasado nada, pero si a continuacion le doy git show, vere que ahora el Head apunta a cabecera. Es decir, el ultimo commit esta pegado a dos branch distintos. Y todavia estoy trabajando en la rama Main (Master). Si ahora le doy git status veo que sigo (On branch master) en la rama master. Pero como me muevo hacia la otra rama (branch)? Eso lo hago mediante git checkout cabecera (me muevo hacia la rama cabecera) y ahora veo que mi git bash dice ahora cabecera. (Para poder ver esto en MacOS debo descargar una consola que se llama zsh) O si no simplemente darle a git status para ver que ya no estamos en la rama master
# A continuacion hacemos un cambio sobre blogpost.html colocando debajo de la linea  <div id="container"> y colocamos <div id="cabecera"> y a continuacion en la linea siguiente escribimos Cabecera, lo cerramos con </div> y guardamos.
# si a continuacion le damos git status vemos que aparece que modificamos un archivo en Cabecera y a continuacion le damos git add blogpost.hml y luego git commit -m creo "Estructura inicial de la cabecera". A continuacion git status me dice que seguimos en cabecera. Y si a continuacion le doy git show me dice que ahora soy el Head de la cabecera. Ya deje el master atras. Y lo ultimo que hice fue agregarle esto al archivo. git log me va a decir cual fue el historial de mis commits.  De master el Head paso a la cabecera y eso es lo que es head al final del dia. Le doy q para salir de aca. Ahora le doy git checkout master y se cambio a master. Y pum desaparecio por completo el id de cabecera. Si ahora le doy git log el ultimo log me dice que la version mas reciente del blogpost y mi head ahora le apunta a master. Volvemos a hacer un git checkout cabecera y ahora los archivos cambian inmediatamente. Esta es la magia de git solo se guardan los cambios e inmediatamente los veo aca en cabecera.  Cuando cree el branch cabecera hice una copia exacta de master y head estaba apuntando hacia main y cabecera porque eran el mismo. Una vez yo empece a hacer cambios e hice un commit 3 donde agregue el div cabecera, esto no se ve en la rama master y aqui el head deja de estar aca y pasa a estar el head de cabecera. Cuando escribo checkout y me devuelvo a master hago que todos los archivos en mi directorio de trabajo cambien a el ultimo commit de la rama a la que le estoy apuntando y entonces el head vuelve a estar aca en main. Head al final del dia es un indicador de cual version de commit estoy viendo de los ultimos archivos. Por ende cuando vuelva a hacer checkout cabecera el head deja de estar aca en main y los archivos vuelven al ultimo commit de esa rama y los archivos vuelven a estar en el branch cabecera
# Para crear un nuevo commit en la branch master combinando los cambios de una rama llamada cabecera le doy git checkout master y a continuacion git merge cabecera. Otra opcion es crear un nuevo commit en la rama cabecera combinando los cambios de cualquier otra rama mediante git checkout cabecera y luego git merge cualquier-otra-rama. Debe recordarse que al ejecutar git checkout para cambiar de rama o al utilizar git commit puedes perder el trabajo que no hayas guardado. Guarda siempre tus cambios antes de hacer git chckout.
# Tengo que decirle quien soy yo para poder hacer los cambios por lo que veo ls
# Proyecto -> git add . -> Staging -> git commit -m "First Change"-> .git
# cp, mv, touch, create -> Working Directory
# git rm --cached <file>, git rm --force <file> <- Working Directory
# git add  -> Staging
# git rm --cached <file>, git rm --force <file> <- Staging>
# git commit -m "Firstcommit", git commit -ammend,  -> git repository
# git reset --soft, git reset --mixed, git reset --hard <- git repository
# Tracked son los archivo que viven dentro de git, no tienen cambios pendientes y sus ultimas actualizacions han sido guardadas en el repositorio mediante la utilizacion tanto de git add . como git commit -m "First commit"
# Staged son los archivos que viven dentro de git y hay registro de ellos porque han sido afectados por git add ., aunque no sus ultimos cambios. Git ya sabe de la existencia de estos ultimos cambios, pero todavia no han sido guardados definitivamente en el repositorio porque falta ejecutar git commit -m "First commit"
# Unstaged son los archivos que viven dentro de git pero no han sido afectados por el comando git add . ni por el git commit -m "First comit" (Git tiene registro de estos archivos, pero esta desactualizado, sus ultimas versiones solo estan guardadas en el disco duro
# Untracked son archivos que no viven dentro de git, solo en el disco duro. nunca han sido afectados por git add . asi que git no tiene registros de su existencia.
# Tienen dos estados al mismo tiempo (Staged y untrackked) cuando se ha dado git add . pero aun no se ha dado git commit
# Git reset HEAD permite sacar archivos del estado Staged para devolverlos a su estado anterior. Si los archivos venian de unstaged, vuelven alli y lo mismo van a untracked si venian de untracked.
# Git commit mueve archivos de unstaged a tracked. Los archivos han sido guardados o actualizados en el repositorio. Git nos pedira que dejemos un mensaje para recordar los cambios que hicimos
# Git rm --cached mueve los archivos que le indiquemos al estado untracked
# Git rm --force elimina los archivos de git y del disco duro. Git guarda el registro de la existencia de los archivos por lo que podremos recuperarlos de ser necesario (pero debemos usar comandos mas avanzados)
ls
# Veo en detalle mediante git config --list para saber si ya le inclui el nombre y el email. Es decir por ejemplo si ya hice: gift config --global user.name "Mi Nombre" y luego git config --global user.email "Mi email"
# Mediante el siguiente comando me muestra un listado de la informacion que ya he incluido y la que aun me falta. Si le doy git config --list --show-origin me va a aparecer listado de donde estan las configuraciones guardadas
# A continuacion con el siguiente comando, podemos ver que anteriormente ya hemos incluido nuestro email y nombre
git config --list
# Puedo ver un archivo historia.txt antes de hacerle una modificacion mediante cat historia.txt por ejemplo. Luego puedo darle code historia.txt y me abre el archivo. Y sobre el archivo abierto lo modifico y luego le doy guardar y cierro. A continuacion vuelvo a darle a git status y me indica que sabe que se modifico. Y ahora puedo volver a hacer otro commit. Sin embargo los cambios aun no han sido anadidos, porque siempre tengo que anadirlos con add. Le doy entonces git add historia.txt o mejor aun git add . (punto porque es mi carpeta actual donde esta todo y lo agrega todos los cambios producidos dentro de esa carpeta o directorio). Ahora al darle git status ya me indica que quedo modificado. Ahora puedo darle git log historia.txt. Ahora escribo git show historia.txt y me muestra los cambios. Me muestra primero la version mas reciente del archivo y el mensaje de ese commit, luego un diff y me muestra la diferencia con el cambio previo a este ultimo. Luego pone en rojo lo que le quite y en verde lo que le agregue. Luego de un error por no haber incluido el mensaje del commit, escribimos el mensaje y luego le damos a Esc + Shift ZZ para que lo envie y guarde y salga del archivo. Utilizo git diff y luego copio los numeros a la derecha de cada mensaje de commit y espacio y el otro numero a la derecha a continuacion y asi comparo las diferencias y me da cuales son las diferencias. Me muestra en verde la version original y en roja la posterior. git diff number1 number2
# Git permite tener una historia real de como ha avanzado el archivo.
## Creas rama principal. Cuando hablamos de Master en realidad hablamos de main. Si en un punto quiero hacer experimentos raros, creo la rama experimental copiando una version de la rama master y le creo una rama especial donde hago los cambios y luego los pruebo con la rama actual y eso lo hago con Merge. La version final o Head. Le pido que se fusione con la rama actual y puedo hacer Bugfixing. por ello lo llamamos base de datos atomica (cambios manejados independientemente). A la experimental la llaman development y a bugfixing lo llaman hotfix. Master siempre es Master. Al hacer un merge puede haber archivos que rompan archivos y eso es lo que llamamos conflictos. Tenemos un directorio de trabajo, un staging y un repositorio. git reset y el numero a la derecha del commit nos permite que vuelva a ese estado todo con git reset hard pero es peligroso. git reset el numero y luego --hard y asi todo se cambia. Si le damos code historia.txt vemos la version anterior. Y al darle git log ves que realmente te borro todo lo que habias hecho antes. Con git log --stat para ver los cambios que se hicieron e inclusive los bytes de los cambios. Si le doy git checkout master historia.txt me devuelve a la version Master que era la ultima version a la que le habia hecho commit. Si lo quiero permanente entonces le doy git add . luego git commit -m "Reemplazo de una version por otra" y ahora le doy a git log --stat.
# git show historia.txt muestra los cambios que ha habido en un archivo
# Con Checkout te traes los cambios previos ubicados en el Main (Master) hacia tu carpeta
# Si quieres trabajar en ramas diferentes para luego realizarles un merge
# Branch main por defecto el proyecto se crea en la llamada Main (Master) y al anadir codigo y guardar cambios haces un commit que es anadir el nuevo codigo a una rama. Esto genera nuevas versiones de esta rama o branch hasta llegar a la version actual de la branch main.
# Branch development cuando hacemos experimentos generamos ramas experimentales (development) basadas en alguna branch main, pero sobre las cuales haces cambios a tu gusto sin necesidad de afectar directamente al codigo principal
# Branch hotfix. En otros casos encuentras un bug o error de codigo en branch main y creas una nueva branch bug fixing o hot fix para hacer los arreglos necesarios. Cuando los cambios esten listos los fusionaras con la branch main para aplicar dichos cambios. Para esto se usa el comando Merge que mezcla los cambios de la rama que originaste a la branch main. Si en alguna linea de codigo ambas versiones tienen modificaciones, entonces se genera un conflicto. De lo contrario no se generara conflicto tras el Merge.
# Todos los commits se aplican sobre una rama. Por defecto empezamoso en la branch main (pero puedes cambiarle el nombre si no te gusta) y generamos nuevas ramas, a partir de esta, para crear flujos de trabajo independientes.
# Git branch permite crear una rama nueva. Si deseas trabajar en una nueva funcion, puedes crear una rama nueva a partir de la branch main con git branch new_branch. Una vez creada, puedes usar git checkout new_branch para cambiar a esa rama.
# Todas tus versiones salen de la  rama principal o Main y de alli puedes tomar una version especifica para crear otra rama de versiones.
# Como se hace un merge. Checkout es producir una nueva rama. Unir dos ramas lo conocemos como Merge. Cuando haces merge de estas ramas con el codigo principal, su codigo se fusiona originando una nueva version de la rama main (master) que ya tiene todos los cambios que aplicaste en tus experimentos o arreglos de errores.
# Podemos aprovechar el registro de cambios de Git para producir ramas, traer versiones viejas del codigo, arreglarlas y combinarlas de nuevo para mejorar el proyecto.
# Combinar ramas (Merge) puede generar conflictos si algunas lineas han sido modificadas en ambas ramas.
# git branch -M main
# Sabemos que git branch nos ayuda a crear una nueva rama dentro de nuestro repositorio y -M nos ayudarÃ¡ a mover todo el historial que tengamos (en caso de que los haya) en master a la nueva rama que estamos creando que se llama main
# Luego por ejemplo podemos hacer git remote add origin git@github.com: iKenshu/master.git y a continuacoin git push -u origin main o
# Tambien podemos dar un push al repositorio existente desde la linea de comandos mediante git remote add origin git@github.com:iKenshu/master.git y luego git branch -M main y luego git push -u origin main
# El comando git checkout + ID del commit nos permite viajar en el tiempo. Podemos volver a cualquier version anterior de un archivo especifico o incluso del proyecto entero. Esta tambien es la forma de crear ramas y movernos entre ellas.
# Por ejemplo: git commit -am "Finalizada la cabecera con diseno azul"
# Luego git status
# git checkout master y perdemos todo el avance realizado hasta ahora
# Ahora agrego un nuevo parrafo, pero perdi la cabeceray puedo hacer un cambio en css. Ahora master esta en courier pero en cabecera esta diferente. Tengo que hacer un add y commit para noo perder los cambios por lo que voy sobre la rama master doy git comit -am "Agregado el contenido adicional del blog  y una mejor tipografia, luego hago git status y vemos y luego git log y veo el detalle de lo ultimo que hice. Luego hago git checkout cabecera y ahora cambiaron mis archivos y vuelvo a tener hyperblog pero quiero tener la fuente en courier como hice en master pero quiero el diseno super cool en la rama cabecera. Debo hacer un merge en la rama donde estoy y es a donde voy a pegar. Quiero traerme a master lo que hice en cabecera. Debo hacer un checkout en master  y poner el head en master y aqui en master invoco el comando merge de cabecera y eso crea un commit nuevo dentro de master y me va a traer el ultimo commit de master y el ultimo commit de cabecera y los va a fusionar. Si llega a haber un conflicto alguien lo tiene que arreglar para que el merge se realize. La rama principal es master hago git checkout master y ya estoy en master y lo verificamos y ahora git merge con el nombre de la rama pero para saber en cual rama estoy le doy git branch y me aparecen las dos ramas y me pone en verde la rama en la que estamos y estando en master le damos git merge cabecera y le doy enter. Un merge es un commit a la rama en donde estas haciendo la fusion. En este caso la rama master.  Al darle git merge cabecera me da un listado de lo que hace.Y tambien me trae los commit que le hice a la cabecera con diseno y me dice que ese commit es el ultimo commit realizado a dicha rama cabecera. Cuando hace el merge me da una parte del numero solamente del que normalmente aparece en el commit. Y vemos que quedo perfectamente fusionado. Ahora doy git commit -am "Agregado el contenido adicional del blog y una mejor tipografia"(cambio de courier a Arial) Doy ahora git commit -am "Volvi a una tipografia menos controversial". Luego git log y me muestra como tenemos la ultima version.Teniamos el head en la cabecera e hicimos un checkout para tener el head en el master y desde el master hicimos un proceso llamado merge e hicimoe el merge con cabecera e hicimos un commit 4 que fusionaba los datos del commit 3 con los del commit 4 y una vez hicimos esos cambios tenemos la version de la cabecera (que incluye el de la cabecera, el css y el html del commit 3 en el commit 4) definitiva en este commit y como no nos gusto courier en el cambio commit 5 nos alejamos en master de lo que dejamos como cabecera. Si hacemos git checkout cabecera vemos que es el mismo post que teniamos antes. Podemos hacer el merge al reves trayendo lo de master a cabecera mediante git merge master (estando ubicados en branch cabecera). Ahora tenemos lo mismo en ambos lugares. Vamos a simular un conflicto voy a modificar las mismas lineas en ambos para que genere un conflicto. Dentro de cabecera cambio cabecera y voy a colocar en color rojo. Ahora hago git commit -am "modifique la cabecera y el color del texto". Vamos a la rama master mediante git checkout master. En master le coloco que es blog maestro y lo coloco azul y tambien le agrego u parrafo adicional. A continuacion doy git commit -am "Agregue suscripcion, cambie la cabecera maestra y puse todo azul?  Ahora hago git checkout cabecera, luego git checkout master. Ahora estamos en master y ahora vamos a fusionar todos los cambios de cabecera en master. Le doy git merge cabecera (desde master) me dice que estoy fusionando estilos y hay conflicto entre ellos y el merge fallo. Para que se complete un merge tiene que haber ocurrido un commit. Si le doy a git log veo los detalles y ahora no tengo un merge completo estoy en estado master merging. Aun no ha ocurrido el commit. Si abro el archivo en bloc de notas veo como menciona en el mismo la sintaxis del conflicto. Abro el css y veo tambien en el bloc de notas como me anuncia el conflicto y yo para resolver ese conflicto decido con cual me quiero quedar y lo modifico sobre el mismo bloc de notas. Pero Visual Studio Code me pregunta cual opcion quiero. Voy a aceptar incoming changes y me deja automaticamente el blog de cabecera y ahora al darle git status me dice que lo hizo. Ahora debo darle git commit - am "Solucione el conflicto de las ramas al fusionar". Pero no se ejecuto el cambio del title voy a git status y me dice que no lo habia modificado y soluciono el conflicto. El problema fue que cuando modifique los cambios en el bloc de notas no le di a guardar. En cabecera sigue en rojo y ahora me voy a git checout master. Los conflictos son parte normal del trabajo. 
# GitHub es un sitio web que tiene por dentro un superservidor de Git en el cual podemos clonar nuestro repositorio y compartirlo con otras personas. Tambien es una interfaz visual de tu repositorio. Es una de las herramientas colaborativas  mas importantes que existe en el mundo del desarrollo. Muchos la llaman la red social de los programadores. 
# Un proyecto es un grupo de repositorios que puedes tener. 
# Vamos a crear un proyecto nuevo y lo llamaremos hyperblog un blog increible para el curso de Git y GitHub. Deseo reiniciar esto con README.md si es muy buena practica y permite explicar a quienes abren mi repositorio que hay en el.
# Hay muchas licencias de codigo abierto, etc. creamos el repositorio publico (o privado) al crearlo publico ya tenemos una direccion en github. Tenemos un archivo README.md y tengo Raw que es el codigo plano que creo ese texto. Luego el Blame que fue el culpable y fue por un initial commit y fui yo mismo. Luego en clone or download le damos y copiamos esa url y volvemos a nuestro repositorio en nuestra rama master y le decimos a git que vamos a agregar un origen remoto de nuestros activos con git remote add origin (la direccion copiada desde la pagina de github). Luego escribo git remote vemos que dice origin. Con esto guarda las credenciales pero da un error pues el remoto contiene trabajo que no esta localmente en mi pc. Debo integrar mis cambios remotos antes de hacer el push. En mi mundo remoto tengo README.md tengo que traermelo primero puedo hacerlo con git pull (git fetch y git merge) y ahora me dice hay un warning de que no hay commits comunes. Dice que hay objetos, deltas cambios que existen, se desempaquetan los objetos y luego dice que la branch master es FETCH HEAD y tengo una nueva rama master que es origin/mastef y me dice que reusa fusionar historias no relacionadas. El README.md es una historia distinta a esta historia. La forma para forzar que ocurra es con git pull origin master --allow-unrelated-histories y asi permite fusionar lo que habia alla con lo que tengo local. Le doy enter y espero y ahora si me permite hacer el merge con la rama master de hyperblog y me trajo README.Md y veo mis archivos git status y veo. Ahor puedo hacer git push origin master y empieza a comprimir resuelve los deltas y el master local se envio al master de github y al recargar todo esta automaticamente en mi pc y en mi pagina de github. Puedo darle click a Blame y me dice quien hizo todos esos cambios. Si en mi version local le doy git confi -l tengo un usuario y un email, y esta correlacionado en github con un usuario que es el usuario que tiene registrada esta cuenta y de este usuario saldran los commit hechos en mi computador actual. Puedo decir que en el blogspot lo voy a editar cambiando el titulo del blotpost poniendo Bienvenido a hyperblog y mpuedo hacer un commit changes en la propia pagina de GitHub y escribo Cambie el titulo del blospost y en optional escrito porque puedo luego abajo le doy commit directly opcion y presiono en el bloton en la pagina github . Ahora tengo el master en github y no lo veo en mi terminal. debo darle git pull origin master y ahora me lo cambio y dice bienvenido hyperblogs y ahora esos cambios estan aca. Dice que lo hizo la rama de alla y me indica que mi HEAD esta actualizado con master y el master que esta en el origen lo que tengo alla arriba en GitHub y ahora pueden ir al github url y ver el status de este proyecto. Si le dan click a commit van a ver la historia entera que colocamos en el proyecto local, pues cuando lo envie dede mi proyecto local envio todo a Git Hub, y no solo lo que habia hecho yo localmente.
# Despues de ver con git branch puedo darle git switch y ver el nombre de la rama y la nueva rama la creo mediante git checkout -v NuevaRama
# Git pull para tenerlo actualizado y luego creo nueva rama mediante git checkout -v Nuevarama  voy a enviar una nueva rama al repositorio y luego creo un merge request
# Luego le doy git remote -v y me muestra los origin  (fetch y otro push) le doy luego a ls -al y veo los permisos. A continuacion doy git push origin master para que envie la rama master y luego me sale una ventana o no y me sale en consola para colocar i usuario y password de git.
# Tambien hay una forma de hacerlo usando git reset. En este caso, no solo volvemos en el tiempo, sino que borramos los cambios que hicimos despues de este commit.
# Hay dos formas de usar git reset: con el argumento --hard, borrando toda la informacion que tengamos en el area de staging (y perdiendo todo para siempre). O, un poco mas seguro, con el argumento --soft, que mantiene alli los archivos del area de staging para que podamos aplicar nuestros ultimos cambios pero desde un commit anterior.
# Para volver a commits previos, borrando los cambios realizados desde ese commit utilizamos:
# git reset --soft[SHA 1]: elimina los cambios hasta el staging area
# git reset --mixed [SHA 1: elimina los cambios hasta el working area 
# git reset --hard [SHA 1]: regresa hasta el commit del [SHA-1]
# Donde el SHA-1 es el identificador del commit
# Escribimos git log para ver
# El git reset --hard puede ser peligroso
git branch -M main
## Agregas repositorio remoto en github (URL)
git remote add origin git@github.com:Armychess/proyectoDemoCursoPrework.git.
## Haces push y envias cambios de commit a github
git push -u origin main
## Si te equivocaste agregando https como repo remoto, arreglalo con
git remote set-url origin git@github.com:Armychess/proyectoDemoCursoPrework.git
## Si no te da error porque no tienes configurado tu user y name de git, github o hitlab. Configuralos de la siguiente manera
git config --global user.email "Miemail"
git config --global user.name "MiNombre"
## Si tienes otro problema de conexion, probablemente sea por la llave ssh
## En tal caso ve al directorio de tus llaves
cd ~/.ssh
## Habilita accesso a llave en dicho directorio
ssh-add id-rsa
## O sigue todos los commandos en su README.md en ~/.ssh como por ejemplo
eval `ssh-agent -s`
ssh-add id-rsa
git remote
# Para que me muestre el fetch y el push
git remote -v
ls -la
# Para que envie al origen la branch master
git push origin master
# Para traerme desde la branch master
git pull origin master
# Para permitirme que haga el merge con la branch master
git pull origin master --allow-unrelated-histories
git pull origin master
git config -l
git pull origin master
# CONFIGURA TUS LLAVES SSH EN LOCAL
git config -l
git config --global user.email "email"
git config -l
# path working directory - pwd (me indica en que directorio o carpeta me encuentro ahora)
pwd
# Especifica el algoritmo para generar la llave
ssh-keygen -t rsa -b 4096 - C "email"
# Passphrase es un password con espacios (contrasena adicional de texto a colocarle a la llave privada)
eval $(ssh-agent -s)
# Agrega la llave al servidor
# ~ significa que estoy en el hogar del usuario (de mis Documentos). Luego con ls me lista los documentos en el directorio donde me encuentro y con ls - la muestra todos los archivos inclusive los ocultos y los incluya en una lista. (a para ver los ocultos)
~
# cd .. si me muestra la ruta entera# En el entorno de linux cd ~ te lleva a su directorio raiz que es de la forma /c/Users/Usuario mientras que en linux o MacOS es algo asi como /Home/Usuario Si le doy ls -al encuentro multiples carpetas y si le doy cd proyecto1 entonces me ubico en el directorio de dicho proyecto. Si doy ls me carga master. Las llaves ssd no son por repositorio o proyecto sino por persona. Con cd volvemos a la carpeta Home y ahi vamos a crear nuestra llave. En este ejercicio vamos a cambiar la configuracio local de Git (cambiaremos el email de platzi al personal de Freddy). Su repositorio tiene otro correo y no el suyo personal. Por ello haremos el cambio como ejercicio . Puedo ir a mi perfil freddier y ver que mi usuario es freddier@gmail.com y ahora voy a recorgdar mi configuracion local mediante git config -l y me muestra mi user.name y mi user.email (team@platzi.com) y para cambiar el email se hace de la siguiente manera. Le doy git config --global user.email "freddier@gmail.com" y luego le doy git config -l y vemos que ya el email cambio. Lo correcto es estar en el home de mi instalacion (chequeo con pwd) /c/Users/Usuario y vamos a darle ssh-keygen -t rsa (la t define el tipo de algoritmo que utilizaremos para crear la llave pues hay distintos algoritmos) ssh-keygen -t rsa -b 4096 -C "freddier@gmail.com" va a decir que genera la llave publica y privada y luego nos pregunta donde guardar la llave. No es recomendable cambiar la carpeta donde la va a guardar y va a ser del tipo /c/User/Usuario/.ssh/id_rsa entonces a continuacion me pedira la contrasena adicional de texto que yo le pongo a mi llave publica y privada.Luego al darle enter me muestra la ruta donde ha guardado la llave publica y privada y me da el key fingerptint  y tambien muestra un random art image (para saber que la llave es de verdad). Ahora podemos abrir por explorer la carpeta y veremos una carpeta .ssh y dentro del mismo las llaves. No puedo mostrar mi llave privada, pero si puedo mostrar mi llave publica (terminada en pub) dandole boton derecho del raton y que habra usando Visual studio Code y dentro de Visual Studio code le doy al click derecho (que lo que hace es copiar esa llave sombreada por mi). Esta llave la debo agregar al entorno que el sistema operativo sepa que la llave existe primero en windows y luego en MacOS. En Windows o en Linux revisar que el servidor de llaves ssh este prendido (programita que revise que las llaves esten corriendo). Para ello escribo eval $(ssh-agent -s) y a continuacion pondra Agent pid y un numero. El Agent me indica que el procesador de ssh esta corriendo pid es el identificador del proceso que confirma que esta corriendo y el 3er paso es agregar la llave al servidor) Debo recordar donde la cree en Home (linux) (/c/Users/Usuario/.ssh/id_rsa) puedes solo escribir el signo de la ene ~ y me muestra el directorio Con cd / estoy en el home y con pwd tambien estoy en el home luego con ~ (este es el signo del bash) me muestra un directorio (/c/Users/Usuario) en realidad ~es una variable que tiene este dato (/c/Users/Usuario) por dentro. Con cd / estoy en el Home y con pwd tambien estoy en el home y si le doy cd ~ y a continuacion le doy pwd veo que estoy en el home. Si a continuacion le doy cd / y luego cd ~proyecto1/ entonces se va a mi carpeta proyecto1 ubicada en mi home, es decir va a /c/User/Usuario/proyecto1. Si ahora le doy cd ~/.ssh/ voy entonces a la carpeta donde estan mis llaves como habiamos visto anteriormente. Y si le doy ls -al puedo ver mis llaves publicas y privadas. Ahora le damos cd otra vez y Ctrl + L (o escribimos clear y le damos enter para limpiar la pantalla). Ahora vamos a agregar la llave que acabamos de crear mediante ssh-add ~/.ssh/id_rsa (aqui estoy agregando la llave privada). En MacOS seria ubicado en Home (para ello utilizo simplemente la variable ~) (/User/freddier) y escribo ssh-keygen -t rsa -b 4096 -C "freddier@gmail.com". Ahora dentro del mundo de MacOS para agegar la contrasena es distinto. Como ejercicio me meto con cd .ssh/ y a continuacion le doy a ls -al donde entonces veo un archivo completamente nuevo llamada known_hosts entonces a continuacion le doy cat id_rsa.pub y veo mi llave publica  y si le doy cat known_hosts veo otro monton de codigo raro y esta es la diferencia entre MacOS y Windows o Linux. Ahora tenemos que evaluar si esta corriendo el ssh agent mediante eval "$(ssh-agent -s)" y me sale  Agent pid y un numero. Para verificar en MacOS moderno Sierra 10.12 (vas arriba de la mantzanita about y cosas por el estilo) vas a tener que modificar el archivo config  y si no existe toca crearlo. El archivo config lo encuentras en tu carpeta .ssh/ por lo que si entramos en esa carpeta y no vemos ese archivo config debemos crearlo mediante vim config y luego escribo Host * (doy enter) y luego escribo AddKeysToAgent yes (doy enter) y en la siguiente linea Usekeychain yes y en la siguiente linea IdentityFile ~/.ssg/id_rsa enter y lo guardamos con Esc + Shift + ZZ Este archivo config no debe tener ninguna extension (ni .txt)  a continuacion doy ls -al y veo el archivo y si le doy cat config veo tal cual lo que yo habia escrito en el mismo. Ahora doy cd para volver a home y a continuacion ssh -add -K ~/.ssh/id_rsa y listo )la K mayuscula es para el Keychange en Mac) (si con la K da error simplemente quitalo y estara bien, son cosas de Mac). Ya hemos creado nuestro entorno local y ahora el proximo paso es conectarnos con GitHub y reeemplazar la conexion https con ssh y empezar a hacer git pull y git push sin necesidad de contrasenas y superseguros.
# Las llaves estan creadas. Tenemos una carpeta ssh no en nuestro proyecto sino en el Home de tu carpeta en tu usuario en tu entorno local. Cada usuario, cada computadora, cada persona tiene que tener una llave unica (si tienes 3 PCs necesitas 3 llaves). Vamos a nuestra carpeta ssh para copiar nuestra clave publica y vamos a nuestro perfil de GitHub y vamos arriba en Settings y a SSH and GPG keys y vamos a crear una nueva llave ssh. Escribimos como Title "Laptop de educacion de Platzi" por ejemplo y en el recuadro donde dice Key pegamos la llave  y presionas el boton add ssh key y luego pones tu contrasena o password para continuar y ahora ves que te confirma que la ha anadido y nunca ha sido usada y ahora ya tengo conectado mi repositorio de GitHub con la llave publica de mi laptop. Ahora voy a mi repositorio Hyperblog y ahi voy a Clone or download el botoncito verde y al agregar el repositorio lo hicimos con Https y ahora le damos y Use SSH y copiamos esa url y vamos de regreso a nuestro entorno local y ahora si nos metemos en la carpeta donde esta nuestro proyecto  con ~proyecto1 y ahi le damos git remote -v Ahora el directorio que vamos a crear lo llamaremos origin y voy a cambiar la url de origin mediante git remote set-url origin y pego mi url copiada en GitHub previamente.  Ahora le doy git remote -v entonces para saber si funciona hacemos cambios para chequear. Tras cambiar en mi local el archivo hyperblog, a continuacion le doy git pull para traerme lo del repositorio y me pregunta si estoy seguro y escribo yes (lo estoy agregando por defecto)  Me dice no hay tracking information para el branch actual, especifica con que rama te quieres conectar, etc. Entonces vamos a hacer git pull origin master y luego le doy para ver git status y si le doy para ver git diff me dice que fue lo que cambio. Doy git commit -am "Una version del hyperblog" y ya agregue el cambio pero me falta enviar el cambio. Antes de eso debo hacer otra vez git pull origin master porque en lo que hice el commit de pronto cambiaron cosas. Entonces ahora para enviarlo le doy git push origin master. Ahora me voy a la pagina de GitHub a mi repositorio y veo blogspot.html que aparentemente fue actualizado hace segundos. Vemos ahi el cambio que hicimos recienteente desde nuestra consola en local ya enviado a GitHub. Vemos que no me pidio mi contrasena en ningun momento. Si en GitHub le doy al boton History veo que el cambio del titulo del blogspot lo hizo freddier y no team platzi uno trabaja en hyperblog y el otro desde mi entorno local pero como tenemos el mismo email somos la misma persona.
# Con git log vemos nuestros commits y si le damos git log --all muestra todo lo que hemos hecho historicamente. Con git log -all graph muestra unas rallitas de como han funcionado los branches y con git log -all --graph --decorate --oneline  muestra todo mucho mas comprimido. Muestra toda la historia de mi proyecto desde que arranco. Creamos un alias mediante alias arbolito="git log -all --graph --decorate --oneline" y ahora escribo solo arbolito y le doy enter.
# Los alias quedan guardados en tu entorno local pero no estamos hablando de alias sino de tags y ahora quiero agregar un tag. Voy a crear un tag mediante copia del numero o hash de mi commit )delque puedo tener una version corta mientras no se parezcan a otros) doy git tag -a v0.1 -m "Resultado de lasprimeras clases del curso" (y a continuacion le pego el hash numerico) y a continuacion le doy enter. Parece no haber pasado nada, Con git tag me muestra lista de todos los tags, pero la forma de saber a que commit o hash esta conectado un tag es mediante git show-ref --tags entonces me muestra un tag y me dice que tenemos creado un tag v0.1 conectado al numero de commit indicado en ese mismo mensaje. Si le doy history (enter) veo que el tag que me aparece es distinto (mas corto) (que es la referencia al momento en el que cree el tag). Si yo ahora doy git status veo que aparentemente no hay nada que enviar porque los tags no son cambios, pero en realidad si hay algo que enviar. La idea es que los tags los pueda ver alguien y son utiles en el GitHub por lo que lo interesante es enviarlo a internet. git pull origin master (antes de hacer cualquier cambio para ver que todo lo que esta en internet me lot raigo para aca). Ahora enviamos el tag a git hub mediante git push origin --tags y recargamos en internet y vemos en el Branch: master tambien veras que tenemos Tag: v0.1 Si hemos creado un tag errado, vamos a arbolito y vemos y luego damos a git tag -a dormido -m "Pohas sadfkhsdf" y ahor lo mando a internet pero primero me traigo lo que hay es buena practica mediante git pull origin master y a continuacion git push origin --tags y me los envia y voy a hyperblog y mi repositorio y veo mi Tag dormido y como me equivoco como borro el Tag dormido lo podemos borrar desde git o desde mi consola y en mi consola hago git tag -d dormido (delete dormido) y ahora doy git status y no hay nada que hacer pero si le doy git pull origin master para traermelos y luego git push origin --tags y voy a hyperblog luego branch masters y luego tags y veo y cuando en la consola le doy git tag no existe. La razon por la cual los tags no se borran automaticamente en GitHub es porque pueden utilizarse como releases. Tenemos que borrarlos de una manera especial mediante git push origin :refs/tags/dormido Ahora al recargar en github vemos que ya no esta. Pero tenemos multiples branches y solo esta el branch master. GitHub nunca se entero de cabecera pues solo le hemos hecho push al master. Ahora veremos como enviar diferentes ramas al servidor.
# Las ramas de desarrollo como la cabecera o el footer la de cabecera la llamaremos header y ahi manejamos eso y en el footer el cambio de la parte de abajo. Primero creamos la historia de las ramas. Primero git checkout cabecera me devuelve a cabecera y me cambia todos los archivos en mi discu duro. git branch me muestra todas las ramas y arbolito me muestra la historia de esas ramas de abajo ya hacia arriba (arriba lo mas reciente). Vemos que nos muestra cuando creamos un tag como dormido y ya lo borramos. Cada rama tiene su propia historia y cuando hizo el merge por eso es importante darle nombre a los commits. Damos a git show-branch nos muestra las ramas y su historia y mediante git show-branch --all me muestra la rama cabecera y master y origin master en remoto y esas son las que actualmente existen. Dos en local y la origin master ocmo remota. Luego muestra historicamente la historia de cada rama. Mediante gitk hace abre el software muy visualmente. Puedo ver que cambios se han hecho. Todos los desarrolladores usan la consola gitk solo es una ayuda. Pero acostumbrate a trabajar con la consola.  Damos git branch y veo dos ramas master y cabecera pero no hemos enviado cabecera le doy entonces git pull origin master y luego git checkout cabecera y luego git push origin cabecera y ahora vemos GitHub hyperblog y dandole a branch master me sale la rama cabecera y la ultima historia fue hace varios dias y fue hecho por teamplatzi. Puedes tener ramas que nunca envias a GitHub. Ahora enviada la rama cabecera creamos dos mas header y footer. git checkout master y ahora git branch header pues importa hacerlo desde la version mas reciente y ahora git branch footer y ahora tengo los branches creados y ahora los envio a internet mediante git push origin header y git push origin footer y asi las envio y ahora veo el flujo de trabajo otro progrmador va a hacer el footer y yo el header y si el de footer quiere fusionar su trabajo de footer con mi trabajo en header. Ahora verificamos en GitHub que tenemos cabecera header y footer. Si como colaborador agregaste erroneamente el mensaje del commit puedes ahcer git commit -amend y a continuacion corregimos elmensaje y luego traemos el repositorio remoto con git pull origin master y ahora ejecutamos el cambio mediante git push --set upstream origin master
# 1.Crear ramas. 2.Asignar rama a cada programador. 3 El programador baja el repositorio con git pull origin master y 4. El programador cambia de rama 5. El programador trabaja en esa rama y hace commits 6. El programador sube su trabajo con git push origin # nombre_rama. 7. El encargado de organizar el proyecto baja, revisa y unifica todos los cambios. 
# Creo directorio imagenes y guardo mi imagen alli, pero es un archivo binario y no debo agregarlo al repositorio. Lo voy a agregar para ver que pasa al agregar un archivo binario a un proyecto. Al master solo envio lo que estoy seguro para la rama de produccion. Doy arbolitoy veo anita se equivoco y agrego la palabra git status le doy git add imagenes/dragon.png y ahora git status y todo bien y ahora git commit -am "logo del header". Recargo gitHub y veo header y veo la carpeta imagenes no existe pues aun no la he enviado a internet y hago git pull origin header para traerme la ultima version del header. Ahora git push origin header y ahora voy a GitHub y dice header le paso algo y recargo y en el branch header aparecio imagenes y sale dragon.png pero esta imagen es pesada 232kb y cada vez que hago cambios mas pesado va a ser mi repositorio.
# Doy git checkout header para pasarme a la branch Header. Ahora en la rama header doy arbolito y veo el primer commit de Anita emocionada que dejo como texto git status. A continuacion git add imagene/dragon.png  luego doy git status y luego git commit -am "logo del header". Ahora un git pull origin header para traer la ultima version de la rama header. Luego git push origin header. Voy a la pagina GitHub recordando que estoy en header y me dice que hace menos de un minuto hubo un cambio en header y veo que en el branch header salio imagenes y si le doy click sale la imagen del dragon. (Esa imagen pesada mientras mas cambios mas pesado sera el repositorio). Ahora cuando le doy a git diff ya no me puede mostrar las diferencias sino que me muestra un archivo completamente binario y eso es un problema (ahora no me maneja los cambios atomicos).Luego de git pull y git push veo que la imagen no me ha guardado los cambios en el branch header imagenes y la imagen no contiene el ultimo cambio que yo hice. Si quieres forzar la actualizacion de la imagen en Windows es con Ctrl + Shift + R. En MacOS es Command + Shift + R. Si realizo cambios bajo mi perfil de Anita donde ella esta actualizando el footer, y le doy git status y tengo cosas que no he cambiado y ahora le doy git commit -am "Color de fondo, logo nuevo y mejor color de header" y ahora Git Status si le doy ahora git checkout master voy a perder todo incluso la carpeta imagenes se borro pues en el master no tengo imagenes. Si vuelvo a darle git checkout header ya lo tengo. Ahora git checkout footer y como anita voy a trabajar en mi propia rama footer y por tanto hago pwd y git status y estoy en el branch master y me voy a traer la rama footer doy git checkout footer y si le doy git status veo que estoy en el branch master y ahora me traigo la rama footer mediante git pull origin footer y me lo trae y lo siguiente es git checkout footer e hice commit al branch footer. Ahora git status estoy en footer y si doy git branch me muestra dos ramas footer y master y con ls -al veo todos los cambios. Creo la estructura en html que me permite agregar el footer a continuacion. Lo veo en chrome en mi carpeta hyperblog en html las tildes acentos salen mal pues los standards de window y linux son distintos y tiene que ver con URF-8. Ver curso de fundamentos de ingenieria de software.Ahora le agrego algo de css para que se vea mejor y a continuacion, hago git status y veo que se modificaron dos y ahora git commit -am "Footer terminado". Ctrl + L para limpiar luego cd .. y luego pwd y luego cd hyperblo/ y luego pwd y luego git status y luego git pull origin footer y ahora git push origin footer y se envian los cambios. Ahora voy a GitHub como Anita y recargo y veo el footer terminado y en el branch footer puedo encontrar los cambios. Y voy a ahyprblog y tengo el cambio del footer. Ahora quiero como Freddy unir los cambios y veo la historia de lo que hizo Anita en el footer hubo una serie de commits y ella hizo un footer terminado y ahora voy a revisar sus cambios y estoy en master por lo que doy git checkout master y luego git checkout header y recargo GitHub luego doy a git checkout footer aun no me lo he traido de internet y doy git pull origin footer y ahora si recargo GitHub y veo los cambios en el footer. Vemos los cambios en blogspot y estilos.css como yo soy el jefe debo fusionar las ramas y voy a continuacion a la rma principal donde quiero hacr el merge, primero a mi cambio increible y voy a rama maestra con git checkout maste ry de ahi fusiono mediante git merge header y me dice haga el merge y quiero explicar qu ehago el Merge branch header para agregar el logo final y a continuacion estando en la rama master y si recargo en gitHub master se ve como yo lo tenia, ahora lo envio a inernet pero primero git pull origin master y luego git push origin master. Tu reto es que hagas merge al footer. Como viste que se hizo el merge al header. Que pasa cuando Anita no es parte del proyecto sino un extrano y eso se llama pull request.
# Para realizar pruebas enviamos el codigo a servidores staging development y antes de realizar merge request se hace un pull request que es un estado intermedio previo. el pull request permite que otro smiembros del equipo revisen el codigo y aprobar el merge a la rama. Permiten a quienes no forman el equipo, trabajar y colaborar con una rama, hacer el pull request y esperar qu elos administradores hagan el merge o pidan algun cambio. La persona que tiene la responsabilidad de aceptar los pull request y hacer los merge son llamados DevOps.
# El pull request es una caracteristica de GitHub no de Git. Permite a externos apoyar en la rama. Para el pull reques se trabaja en una rama paralela git checkout -b <rama> luego git commit -am "Comentario" luego se suben al remoto los cambios git push origin <rama>. En GitHub se hace el pull request comparando la rama master con la rama del fix. Uno o dos colaboradores dan feedback en el chat  de pull request y el colaborador hace los cambios que desea en la rama y lo vuelve a subir al remoto (automaticamente jala los cambios que se hagan en la rama, en remoto) Se aceptan los cambios en GitHub y luego se hace merge a master desde GitHub. Para utilizar el pull request comenzamos con git pull origin master y luego git branch fix-typo y luego git branch y vemos. Ahora git checkout fix-typo y ahora hago cambios en mi archivo blogpost y guardamos. Luego git status y luego git diff y luego git push origin fix-typo soy freddy y soy colaborador del repositorio. Voy a GitHub branch fix-typo y ese branch podemos presionar boton New pull request le decimos en GitHub que de master lo compare con fix-typo luego le doy en la consola git status y luego git commit -a "Tildes y typos arreglados en el post" y ahora git push origin fix-typo y ahora si soy el dueno del repositorio, estoy en la rama master y le doy New pull request, me va a decir quieres comparar la rama fix-typo con la rama master y se puede hacer una fusion. Toma el nombre del commit y lo pone como el nombre del pull request. Puedo agregarle "No debimos pasar este error a master." Podemos agregar personas en Reviewer que revisen esto. Que es DeBox que te explica como crear un curso de integracion continua, etc. Lo que Armando hace con Jira. Al darle en la pagina GitHub al boton pull request creo un pull request y lo que estoy haciendo es decirle a alguien esto no debimos haberlo hecho. Ahora Anita entra y ve que ahora hay un pull request, En general Squash y Rebase son malas practicas y no deberian hacerse. Hago un git pull origin fix-typo y luego git push origin fix-typo cambio a entidades html en vez de tildes en html &iacute; y asi coloco con acento visible para todos los navegadores. Como freddy voy a GitHub y veo fix-typo para verificar que todo este bien y veo View#1 y si veo file change veo que se ejecutaron los cambios. Abajo en Write en GitHub le escribo por favor hazme el merge. Ahora entra Anita y ve el Write que hizo Freddy y ve que se cambiaron las tildes y escribo Excelente. Eso era! y apruebo los cambios.  Y le doy submit review, pero que hayan sido aprobados no significa que el merge se haya ejecutado solo significa que tengo un check de los cambios y alguien tiene que hacer el merge. O bien Anita o Freddy pues debe respetarse quien lo hace y esto es el code Review. Para hacer el Merge request hacemos commit desde GitHub y aparece Pull request succcessfuly merged. Puedo borrar el branch pues no lo necesito para no llenarme de branches. Esta verficado que este commit lo hizo en GitHub Anita. Ahora vuelvo a mi rama fix-typo que no esta por haber sido borrada y ahora hago git pull origin master y luego git log veo que el ultimo cambio fue que Anita puso en master junto con master un Merge y si ejecuto arbolito, el arbol fix-typo existe y tiene su historia. Los pull request del lado de Git no existen. Un pull request es una pausa justo antes de fusionarlo. Y code review es la mejor de las ideas para tener el trabajo completo. Despedimos a Anita de platzi y aqui los pull request son importantes se hace un clonar y crea un Fork de manera distinta.
# Los forks o bifurcaciones crean una copia del estado actual del repositorio en GitHub que servira como otro origen y podra clonarse. Al hacer un fork de un proyecto te conviertes en dueno del repositorio fork, puedes trabajar en este con todos los permisos teniendo solo alguna historia en comun. Los fork es como funciona el open source porque una persona puede no ser colaborador de un proyecto pero puede contribuir al mismo. Para hacer un fork remoto desde GitHub, este permite al colaborador hacer pull request desde su repositorio propio. Por lo que se genera un remoto adicional desde consola. git remote add <nombre_del_remoto> <url del remoto> luego git remote upstream https://github.com/freddier/hyperblog y al crear un remoto adicional podemos hacer pull desde el nuevo origen (si tenemos permisos podremos hacer fetch y push) mediante git pull <remoto> <rama> y luego git pull upstream master y entonces este pull nos traera los cambios del remoto por lo que se estara al dia en el proyecto. El flujo de trabajo cambia, en adelante se estara trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request. Mediante git pull upstream master y luego git push origin master. En fork clono el proyecto y creo una bifurcacion del mismo. Le doy en la pagina GitHub a Fork y estoy clonando. Anita copia el https de la pagina GitHub y luego le da ls -al y luego git clone y pega el link. Luego puedo darle git status y se que estoy en una rama master.
# Haciendo deployment a un servidor. Deploy es el proceso de enviar al servidor uno o varios archivos bien servidor de prueba, desarrollo o produccion. Se entra a la carpeta de los archivos del servidor y se copia link en clone eligiendo entre https o ssh del repositorio a contribuir y en la carpeta deseada se clona el repositorio. Mediante git clone url y luego Deploy: y luego se realizan cambios y commit en GitHub y luego se trae al repositorio local las actualizacion para el servidor en la carpeta de los archivos del servidor. Mediante git pull ramaRemota main. Se debe proteger el archivo .git bien mediante Travis (pago) o Jenkis (open source)
# .gitignore es una lista que hacemos de archivos que vamos a ignorar. debo darle git add .gitignore luego git status y luego git commit -am "Agregue una imagen al blog"No la agrego al repositorio. Debe ir en un content delivery network. Con git status y luego git push origin master no pudimos enviarlo hubo cambios en el repositorio y el cambio ocurrio como un commit en GitHub que no nos trajimos al local hay que hacer un git pull origin master y luego git push origin master. En GitHub vemos  .gitignore y ahi no est la imagen pues la subo por cualquier otro modo que no sea GitHub. En imgur.com puedes agregar cualquier imagen  sin tener que tenerla en el repositorio.
# Pasos para subir un repositorio a GitHub Pages
# Para crear GitHub Pages le doy en GitHub crear nuevo repositorio y completo Repository name y Description y le doy al boton Create repository. Voy al home y le doy git clone y pego el ssh que copie de la pagina de GitHub y encuentro mi nuevo directorio y doy ls -al y la carpeta esta vacia. Ahora debo crear nuevo archivo mediante vim index.html y luego de crearlo le doy git add index.html  luego doy git comit -am "Mi primer diseno en GitHub"hago git pul origin master y luego git remote -v y veo lo que tengo y doy ahora git push origin master y ahora voy a la pagina GitHub y veo mi repositorio ahora tengo que ir a mi nombre de usuario y es freddier.github.io mientras yo haya colocado un repositorio con mi mismo nombre de usuario de GitHub y tenga un index.html va a funcionar pero al darle enter no funciona pues me falta dejar configurado que este repo sea el que me carga el GitHub pages. En freddier voy a settings y abajo en la opcion GitHub Pages y le doy en None y tomo el master branch y ahora quedo grabado pues faltaba decirle la rama en la que debia mostrarlo y ahora (puedo tambien tener un dominio personalizaod, etc.) ahora conectado con mi master branch esta funcionando bien https"//freddier.github.io.freddier y a otros les carga en la raiz tienen su coleccion de proyectos que han agregado como hago? Pues para que me cargue en la raiz desde cierta fecha GitHub cambio las regals entonces para que te funcione como una pagina principal tienes que cambiarlo a freddier.github.io y ahi le das al boton rename ya estamos. Vamos a settings y donde GitHub Pages e lo detecta y entro a mi pagina y ya me esta funcionando perfectamente.Voy a settings de Hyperblog y le pongo branch master y aqui esta  pero no carga la foto porque es un binario. 
# Git rebase para reorganizar el trabajo realizado. Rebase es solo para repositorios locales. Es un parche. Cuidado con rebase. Estamos en branch master y abrimos historia.txt y agregamos un commit que llamamos master1 doy git commit -am "Master 1" ahora le doy arbolito y vemos que la version mas reciente es el head de nuestra version local y ahora creamos una nueva rama mediante git branch experimento y luego git checkout experimento y ahora git commit -am "Exp 1"y ahora arbolito y veo y a continuacion doy git commit - am "Exp 2" y ahora git checkout master y si regreso a git checkout experimento tengo los dos. Significa que los branches se desconectaron y quiero pegarlos y que se peguen a la rama master. Estando en la rama experimento me pego a la master mediante git rebase master estoy dentro de la rama experimento le digo que me pegue mi historia a la del master y ahora me dice que esta actualizada pues master no ha cambiado y ahora vuelvo a la rama master y agrego git commit -am "Master 2"y ahora git checkout experimento y ahora master 2 no existe y ahora la rama adelantada esta en Master 2 cerramos y ahora le doy desde la rama experimento doy git rebase master y veo en la rama experimento me trajo todo a la master si desplego arbolito la historia cambio ahora origin master es el original y luego Master 1 y MAster 2 y luego experimento. La historia ya no es que experimento arranco con un commit atras sino ahora en un commit adelante. Cuidado pero me sirve para hacer un cambio local. Es una mala practica porque cambia la historia de donde arranco el branch. Ahora puedo hacer un merge con la rama anterior y doy git checkout master y ahora git rebase experimento (dentro de master) primero el rebase a la rama que voy a desaparecer de la historia y luego rebase a la rama principal. Luego de git rebase experimento veo y a continuacion le doy arbolito veo aparece la rama experimento como si siempre hubiera tenido el mismo contenido de la rama master. Ahora le damos git pull origin master y luego git push origin master y ahora se envio a internet. Revisemos en GitHub hyperblog la historia de historia.txt y veo la historia de ese archivo. Se le hizo Master 1 MAster2 luego Exp 1 y luego Exp 2 como el primer rebsse fue master y luego el 2do y a nivel de historia no paso nada, la rama experimento no existe. Puedo darle git branch -D experimento y ahora arbolito todo perfecto y eso es un rebase. Una forma de hacer cambios silencioso de otras ramas. 1ro donde los cambios que queremos modificar y luego rebase a la rama final. Rebase ajusta donde ocurrio el primer commit pero los problemas es que no queda historia y no se sabe quien hizo que. Puede generar conflictos por lo que hay que sr muy cuidadoso.
# El stashed sirve para guardar cambios para despues. Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de branch sin perder el trabajo que aun no guardamos en un commit. Es util pues permite cambiar de rama pues tenemos cambios sin guardar  que no necesariamente es bueno para un commit pero no queremos perderlo. El stashed permite cambiar de rama hacer cambios y trabajar en otras cosas y mas adelante retomar el trabajo que teniamos en Staging, pero que podemos recuperar, ya que los guardamos en el Stash. El comanto git stash guarda el trabajo actual del Staging en una lista disenada para ser temporal llamada Stash, para que pued ser recuperado en el futuro. Para agregar los cambios al stash se usa git stash  y podemos poner un mensaje para diferenciarlo en git stash list por si tenemos varios elementos en el stash mediante git stash save "mensaje identificdor del elemento del stashed". El stashed se comporta como una Stack de datos como tipo LIFO y asi podemos acceder al metodo pop. El metodo pop recuperara y sacara de la lista el ultimo estado del stashed y lo insertara en el staging area, por lo que es importante saber en que branch te encuentras para poder recuperarlo, ya que el stash sera agnostico a la rama o estado en el que te encuentres. Siempre recuperara los cambios que hiciste en el lugar que lo llamas. Para recuperar los ultimos cambios desde el stash a tu staging area utiliza el comando git stash pop y para aplicar los cambios de un stash especifico y eliminarlo del stash usa git stash pop stash@{ <num_stash>} y luego para retomar los cambios de una posicion especifica del stash puedes utilizar git stash apply stash@{<num_stash>} donde el <num_stash> lo obtienes desde el git stash list Para ver la lista de cambios guardados en Stash y poder recuperarlos podemos utilizar git stash list
# Para crear una rama con el stash lo hacemos mediante git stash branch <nombre_de_la_rama>"y para crear una rama y aplicar un stash especifico (obtenido desde git stash list podemos utilizar git stash branch nombre_de_rama_stash@{<num_stash>} Con esto se creara una rama con el nombre de la rama, te pasaras a ella y tendras el stash especificado en tu staging area. Para eliminar los cambios mas recientes dentro del stash (el elemento 0) podemos utilizar git stash drop pero si conoces el indice del stash que queires borrar (mediante git stash list) puedes utilizar el comando git stash drop stash@{<num_stash.>} Donde el <num_stash> es el indice del cambio guardado. Si en cambio deseas eliminar todos los elementos del stash, puedes utilizar git stash clear.. El cambio mas reciente al crear un stash siempre recibe el valor 0 y los que estaban antes aumentan su valor. Al crear un stash tomara los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario agregarlo al Staging Area con git add { nombre_archivo} con la intencion de que git tenga un seguimiento de ese archivo o utilizando el comando git stash -u (que guardara en el stash los archivos que no esten en el staging). Al aplicar un stash este no se elimina, es buena practica eliminarlo.
# Si cometo un error y he borrado una linea de un archivo por ejemplo de html, como recupero lo que tenia? Puedo hacerlo mediante git stash y al darle enter vuelve al estado interior pues ahora tengo guardados los cambios que hice en un lugar temporal que puedo ver mediante git stash list y veo Work In Progress) y su identificacion numerica. Entonces a continuacion hago git stash pop y asi abro el stash que teniay le doy CTRL + Z y guardo. Luego doy git status y veo. Otra cosa que puedo hacer es guardar mis cambios y ponerlos en una rama pero primero cambio el titulo de cabecera y a continuacion tras grabar le doy git stash y quedo guardado. Ahora git stash list vuelvo a verlo normal. Ahora git stash branch english-version luego git branch y luego git status veo que he modificado el archivo pero el estado en que estaba el archivo era modificado pero no lo habia agregado ni hecho commit y ahora hago git commit -am "I speak english now"y luego git status y veo y luego git branch y a continuacion git git checkout master y luego a git stash list donde no tengo nada. Luego doy git stash y luego git stash list y ahora git stash drop y luego git stash list y ya no existe y asi puedo tener en temporal los cambios y luego recuperarlos. 
# Podemos tener en nuestro repositorio archivos que no deberian formar parte de nuestro directorio de trabajo y para ello el comando clean actua en archivos sin seguimiento (en el archivo de trabajo pero aun no anadidos al indice de seguimiento del lrepositorio mediante git .add). Para revisar que archivos no tienen seguimiento usamos $ git clean --dry-run y para eliminar los archivos listados de no seguimiento usamos git clean -f  Puedo darle git clean --dry-run que simula como seria el borrado sin aun hacerlo y a continuacion le doy git clean -f para borrarlos y a continuacion git status y veo  que no se borro la copia y a Git no le importan las carpetas sino los archivos y sigue trackeado tampoco las copias de imagenes se borraron. En nuestro .gitignore todos los .jpg tienen que ser ignorados y por eso las imagenes aunque no esten siendo trackeadas pues git solo borra las cosas que puede indexar. 
# Git Cherry-pick permite tomar uno o varios commits de otra rama sin tener que hacer un merge completo por lo que podriamos aplicar los commits relacionados con nuestra funcionalidad en la rama master sin un merge. Se ejecuta mediante git checkoutmaster y si queremos una referencia de confirmacion usamos git log y si queremos utilizar la confirmacion 'f' en la rama master nos asegurmos primero de que estamos en esa rama master y damos git cherry-pick f pero usar Cherry-pick es una mala practica porque estamos reconstruyendo la historia.  Si damos estando en master doy git stash y luego git stash branch readme-mejorado y ahora en la rama mejorado doy git commit -am "Creditos al team Platzi"y si hago git status tengo esos cambios en la rama mejorado y si doy arbolito veo el head en el momento y antes el english-version y luego el origin/master tambien puedo verlo con git log --oneline y cuando hago esto lo veo. Puedo hacer otros cambios y guardamos y luego damos git commit -am "ejemplos en windows, linuz y Max"y luego git log --oneline y vemos que aparece y a continuacion damos tras modificar agregando disponible para todas las edades y doy git commit - am "diverso y atractivo pra todos" y ahora doy git log --oneline y veo que tengo 3 commit que agregue y ahora doy git checkout master y veo pero necesito que en el master este y estan en la rama mejorado y si hago ahora git checkout a la rama git mejorado mi jefe dice quiere solo una parte del cambio entonces me voy al master y doy desde el master git cherry -pick y ahi me traigo solo ese commit que fue el 1ro de los tres que hicimos en la rama mejorado. doy git log--oneline  para encontrar cual fue ese commit. No lo voy a ver desde aca pues estoy en master y por tanto doy git checkout readme-mejorado y luego git log --online y ahi lo encuentro copio el numero y vuelvo a master y desde ahi le digo git cherry-pick y espacio y pego el numero y me lo trajo. Esto es traerme un commit de otra rama a mi rama master. luego doy git status y luego git log --online y ahora git pull origin master para traerme la ultima version en el servidor y luego git push origin master y voy a GitHub y recargo la pagina y veo hyperblog y veo que lo cargo y voy a README.md y voy a verlo como si hubiera ocurrido en master. Ahora hago un merge git merge readme-mejorado y estoy en la rama donde voy a hacer la fusion y me voy a traer la fusion y me trae un conflicto entre lineas y Visual Studio Code me lo muestra bien y si abro el archivo veo los detalles del conflicto. Lo modifico a mano y luego de guardarlo le doy git status y luego git commit -am "Readme mejorado"que es la rama local y ahora git pull origin master al master local para los cambios que hayan podido ocurrir y luego git push origin master.  Voy a hyperblog en GitHub y ahi lo tengo. Es mucho mejor que usar el cherry pick, usar el merge o un checkout al head.
# A continuacion Git Reset y Reflog para usarlo en caso de emergencia. Digamos que tuviste un mal dia y borraste blogpost y luego hiciste sin pensar git commit -am "Blahdjkgshsdf amo Platzi"y luego hiciste git checkout cabecera y despues un git merge master y luego hiciste un cd .. y luego ves al dia siguiente a ver que hicistes y comienzas con git log a ver que paso. Haces un gitk para ver  o por dios que hice anoche. Hay un comando que no olvida nadadigamos que hice git checkout master y despues de eso hice git branch -D cabecera y si ahora voy a git log es coo si nunca hubiera existido y en ese momento puedo hacer git reflog y ahi se ve todo incluso los Head que se han ido moviendo y los commit y checkout, etc. y tratas de buscar el ultimo Head donde todo era correcto y vas a master y le das git reset HEAD{4} y si le doy git status y luego puedo sacar ese cambio justo antes del commit pero quiero como estaba todo entonces vamos a hacer un reset hard mediante git reset --HARD c894560 y con esto todo vuelve a la normalidad. Si le doy a arbolito es como si no hubiera pasado nada. Si le doy git pull origin master y luego git push origin master y voy a GitHub a la historia de commit no veo ninguno de los errores cometidos. El HEAD{4} era el ultimo commit donde todo estaba correcto.
# Reconstruir commits con amend permite modificar el commit mas reciente (enmendar) mediante git add -A y luego git commit --amend (en git add -A es para hacer uso de amend los archivos deben estar en staging y luego con git commit --amend remienda el ultimo commit).
# Buscar en archivos y commits de Git con Grep y log. Quiero buscar cuantas veces en el proyecto utilizamos la palabra color y para buscar utilizamos git grep color. Si utilizamos git grep -n color nos saldra un output el cual nos dira en que linea esta lo que estamos buscando. Con git grep -c color nos saldra un output el cual nos dira cuantas veces se repite esa palabra y en que archivo. Si queremos buscar cuantas veces utilizamos un atributo de HTML lo hacemos con git grep -c "<p>". Si lo que quiero buscar esta en la historia de los commit le doy git log -S "cabecera" y muestra todas las veces en las que utilice la palabra cabecera en los commit. 
# Tambien hay alias a nivel global. # Los siguientes comandos colaborativos: git shortlog -sn: muestra cuantos commit han hecho cada miembro del equipo. git shortlog -sn --all: muestra cuantos commit han hecho cada miembro del equipo, hasta los que han sido eliminados. git shorglog -sn --all --no-merge: mmuestra cuantos commit ha hecho cada miembro, quitando los eliminados sin los merges. git blame ARCHIVO: muestra quien hizo cada cosa linea por linea  git COMANDO --help: muestra como funciona el comando. git blame ARCHIVO -Llinea_inicial,linea_final: muestra quien hizo cada cosa linea por linea , indicandole desde que linea ver. Ejemplo -L35,50. git branch -r: se muestran todas las ramas remotas. git branch -a: se muestran todas als ramas, tanto locales como remotas. Con git shortlog -sn muestra como un blog por persona de cada miembro del equipo. git shortlog -sn --all completo. Luego git shorlog -sn --all --no-merges y veo los commit que hizo cada uno. Luego para crear git stats le digo git config --global alias.stats "shortlog -sn --all --no-merges" y luego al darle git stats si lo ejecuta. Con git blame blogpost.html  y otro git blame -c blogpost.html para ver mas detalle dar git blame --help. git blame css/estilos.css -L35,53 (muestra solo esas lineas y quienes fueron los que las han ido cambiando). Y con mas detalle mediante git blame css/estilos.css -L35,60 -c Por ultimo tenemos ramas locales y ramas remotas pero no sabemos como verlas. Con git branch veo mis ramas actuales pero con git branch -r veo las ramas remotas y si tengo git upstream -r Y si le das git branch -a ves en verde la master en blanco las otras locales y en rojo las remotas. En la pagina GitHub donde dice Pulse te muestra mas detalles. En Code frequency dentro de GitHub puedo ver cuanto codigo se anade y cuanto se borra por semana. En Network puede verse la historia de como se fue trabajando a lo largo del proyecto.
# Debemos tomar la llave SSH y hacer un git clone #SSHexample en mi computador local (Home). Luego, accederemos a la carpeta nueva que aparece en nuestra mÃ¡quina local. Creamos un nuevo archivo que se llame index.html   Guardamos los cambios, hacemos un git pull y seguido de esto un git push a master. Vamos a las opciones de settings de este repositorio y, en la parte de abajo, en la columna Github Pages, configuramos el source o fuente para que traiga la rama master. Guardamos los cambios. DespuÃ©s de esto, podremos ver nuestro trabajo en la web como si tuviÃ©ramos nuestro propio servidor.
# Siempre que yo le de cd me llevara a la carpeta o directorio Home
# Con Ctrl + L limpia la consola (clear)
# /mnt/ es donde se encuentra la raiz en Windows. En Windows la minuscula o mayuscula no importan. cd /c o cd /C
# En Windows el espacio no es importante como si lo es en Linux y MacOS
# Change directory cd (cambiar directorio)
# cd . sigo en el mismo directorio y cd .. me lleva a la carpeta anterior en la que estaba previamente.
# cat me muestra el contenido de un archivo o permite agregarle texto "append" bien mediante cat > archivo.txt y a continuacion escribo el texto que desee y al terminar presionoa CTRL + d para salir dejando grabado lo escrito. Tambien puede hacerse mediante cd >> archivo.txt y todo lo que escriba a continuacion sera agregado al final del archivo.
# La historia de todos los comandos escritos hasta ahora la obtengo mediante history
# Para volver a repetir un comando invoco el numero del comando de este listado precedido por !
# Para borrar archivos rm vacio.txt (cuidado con rm pueden borar por completo el disco duro) Puedes borrar rm - rf
# Ayuda para el comando: comando --help
cd /
pwd
cd ~
cd /
cd ~personalProyectos
cd ~/.xxh/
ls -la
ssh-add ~/.ssh/id_rsa
# ssh-keygen -t rsa -b 4096 -C "eMail"
# CONEXION A GITHUB CON SSH
git remote -v
# git remote set-url origin git@github.com:freddier/hyperblog.fit (que es su SSH copiado desde la propia pagina de github)
git pull
git pull origin master
git status
git diff
git commit -m "Una version de hyperblog"
git push origin master
# TAGS Y VERSIONES EN GIT Y GITHUB. Para ver lo que paso.
# Con git log veo los cambios realizados entre versiones 
# Si le doy git log --stat me da en detalle los cambios por cada archivo
# Los servidores remotos pueden estar alojados en GitHub, GitLab, BitBucket, entre otros. Guardan el mismo repositorio que tienes en tu PC y nos da una URL con la cual podremos todos acceder a los archivos del proyecto. Asi, el equipo podra descargarlos, hacer cambios y volverlos a enviar al servidor remoto para que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.
# Comando para trabajo remoto con GIT
# git clone url_del_servidor_remoto: permite descargar los archivos de la ultima version de la branch main y todo el historial de cambios en la carpeta .git
# git push: tras hacer git add . y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.
# git fetch: trae actualizaciones del servidor remoto y las guarda en nuestro repositorio local
# git merge: lo utilizamos con servidores remotos para combinar los ultimos cambios del servidor remoto y nuestro directorio de trabajo.
# git pull: Basicamente, git fetch y git merge al mismo tiempo.
# git log --oneline: muestra el id commit y el titulo del commit.
# git log --decorate: muestra donde se encuentra el head point en el log
# git log --stat: explica el numero de lineas que se cambiaron brevemente
# git log -p: explica el numero de lienas que se cambiaron y muestra que se cambio en el contenido
# git shorlog: indica que commits ha realizado un usuario, mostrando el usuario y el titulo de sus commits
# git log --graph --oneline --decorate y
# git log --pretty=format:"%cn hizo un commit %h el dia %cd": Muestra mensajes personalizados de los commits
# git log -3: limitamos el numero de commits
# git log --after="2018-1-2"
# git log --after="today"y
# git log --after="2018-1-2"--before="today": commits papara localizar por fechas
# git log --author="Name Author": commits hechos por autor que cumplan exactamente con el nombre
# git log --grep="INVIE": busca los commits que cumplan tal cual esta escrito entre las comillas
# git log --grep="INVIE"-i: busca los commits que cumplan sin importar mayusculas o minusculas
# git log --index.html: busca los commits en un archivo en especifico
# git log -S "Por contenido": buscar los commits con el contenido dentro del archivo
# git log > log.txt: guardar los logs en un archivo txt
git log
git log --all
# Muestra unas rayitas de como han funcionado los branch
git log -all --graph
# Para hacerlo mas comprimido
git log --all --graph --decorate -oneline
alias arbolito=git log --all --graph --decorate -oneline
arbolito
# Creacion de un Tag. Primero copias el hash de tu commit, puedes copiar el corto.
git tag -a v0.1 -m "Resultado de las primeras clases del curso" (y aqui pego el hash)
git show -ref --Lags
git status
git pull origin master
git push origin --tags
# Como borrar un tag
git tag -d (el nombre del tag)
git pull origin master
git push origin --tags
git tag
# Aunque lo borres internamente queda en git hub debemos
git push origin :refs/tags/(el nombre del tag)
git branch
# Como enviar diferentes ramas al servidor GitHub
git show-branch
git show-branch --all
# Te abre en un software de manera ultravisual las ramas y los tags y cambios hechos.
gitk
# Todos los programadores profesionales usan la consola y no esta clase de ayudas.
git pull origin master
git checkout cabecera
git push origin cabecera
# Puedes tener branch que nunca envias a Git y otras que siempre envias
git checkout master
git branch header
git branch footer
git branch
git push origin header
git push origin footer
# Para fusionar el header con el footer de otro programador
# CONFIGURAR MULTIPLES COLABORADORES EN UN REPOSITORIO
# FLUJO DE TRABAJO PROFESIONAL: HACIENDO MERGE DE RAMAS DE DESARROLLO
arbolito
git add imagenes/dragon.png
git status
git commit -ma "logo del header"
git pull origin header
git push origin header
# Los archivos binarios como Word e imagenes no deben agregarse a repositorio son muy pesados
# Para ver las diferencias entre diferentes versiones de cambio copio el numero de un commit con doble click y lo hago mediante: git diff numero1 numero2
# Me muestra si coloco primero la version mas reciente en rojo y con signo menos delante todo el texto que fue agregado en la version mas reciente y en verde con signo mas lo que fue eliminado en la version previa
# Si coloco primero la numeracion de la version anterior y luego el de la version mas reciente, entonces coloca en rojo y con menos lo que se elimino y en verde con + lo que se agrego
git diff
git commit -ma : logo mejorado"
git pull origin header
git push origin header
# FLUJO DE TRABAJO PROESIONAL CON PULL REQUESTS
# Para definir los permisos (todos para el owner y para el grupo, pero solo 4 para otros) chmod 774 hashcat.hcstat
# UGO To remove the write permission for the user chmod u-w hashcat.hcstat